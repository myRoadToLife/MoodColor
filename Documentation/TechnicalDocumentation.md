# Техническая документация проекта MoodColor на 04.05.2025

## 1. Общее описание архитектуры

### 1.1 Обзор
MoodColor - мобильное приложение на Unity для Android, которое позволяет пользователям отмечать свои эмоции с визуализацией в виде банок с жидкостью и цветными пузырьками. Проект использует модульную архитектуру с внедрением зависимостей и строгим разделением ответственности.

### 1.2 Ключевые архитектурные принципы
- **SOLID принципы**: Разделение ответственности, открытость-закрытость, инверсия зависимостей
- **Слабая связанность**: Через систему внедрения зависимостей
- **Модульность**: Независимые сервисы с четко определенными интерфейсами
- **Расширяемость**: Архитектура позволяет легко добавлять новые функции

### 1.3 Структура проекта
```
Assets/
├── App/
│   ├── Develop/
│   │   ├── EntryPoint/          - Точка входа в приложение
│   │   ├── DI/                  - Система внедрения зависимостей
│   │   ├── CommonServices/      - Общие сервисы
│   │   │   ├── Firebase/        - Интеграция с Firebase
│   │   │   ├── Emotion/         - Система эмоций
│   │   │   ├── GameSystem/      - Игровые механики
│   │   │   ├── DataManagement/  - Работа с данными
│   │   │   └── ...
│   │   ├── AppServices/         - Сервисы приложения
│   │   ├── Utils/               - Утилиты
│   │   └── Configs/             - Конфигурации
│   ├── Scenes/                  - Сцены
│   ├── UI/                      - Пользовательский интерфейс
│   └── Resources/               - Ресурсы
├── Prefabs/                     - Префабы
└── Settings/                    - Настройки
```

## 2. Ключевые системы

### 2.1 Система внедрения зависимостей (DI)
Ядро архитектуры приложения - `DIContainer`, позволяющий регистрировать и разрешать зависимости сервисов.

#### 2.1.1 Ключевые интерфейсы
- `IInjectable` - маркерный интерфейс для классов, использующих внедрение зависимостей
- `IInitializable` - интерфейс для сервисов с методом инициализации
- `IServiceRegistrator` - интерфейс для регистрации сервисов в контейнере

#### 2.1.2 Использование
```csharp
// Регистрация сервисов
container.RegisterAsSingle<IEmotionService>(c => new EmotionService(
    c.Resolve<PlayerDataProvider>(),
    c.Resolve<IConfigsProvider>(),
    c.Resolve<EmotionConfigService>()
));

// Получение сервиса
var emotionService = container.Resolve<IEmotionService>();
```

### 2.2 Система эмоций (Emotion)
Ядро функциональности приложения, отвечающее за управление эмоциями пользователя.

#### 2.2.1 Основные компоненты
- `EmotionService` - главный сервис управления эмоциями
- `EmotionTypes` - перечисление типов эмоций
- `EmotionData` - структура данных для хранения информации об эмоции
- `EmotionHistory` - история эмоций пользователя
- `EmotionMixingRules` - правила смешивания эмоций
- `EmotionStatistics` - статистика по эмоциям

#### 2.2.2 Ключевая функциональность
- Добавление/удаление эмоций
- Смешивание различных типов эмоций
- Отслеживание истории эмоций
- Статистика и тренды эмоций
- Синхронизация с Firebase

#### 2.2.3 Структура данных
```csharp
public class EmotionData
{
    public EmotionTypes Type { get; set; }
    public float Value { get; set; }        // Текущее значение
    public float Intensity { get; set; }    // Интенсивность
    public Color Color { get; set; }        // Цвет эмоции
    // ...дополнительные свойства
}
```

#### 2.2.4 События
```csharp
public event EventHandler<EmotionEvent> OnEmotionEvent;
public event Action<bool, string> OnSyncComplete;
public event Action<float> OnSyncProgress;
```

### 2.3 Firebase интеграция
Обеспечивает синхронизацию данных пользователя и аутентификацию.

#### 2.3.1 Основные компоненты
- `DatabaseService` - сервис работы с базой данных
- `EmotionSyncService` - синхронизация эмоций с Firebase
- `EmotionHistoryCache` - кэширование истории эмоций
- `FirebaseTaskHelper` - вспомогательный класс для Firebase задач

#### 2.3.2 Функциональность
- Аутентификация пользователей
- Хранение и синхронизация данных
- Разрешение конфликтов
- Оптимизация трафика и производительности

### 2.4 Система геймификации
Повышает вовлеченность пользователей через игровые элементы.

#### 2.4.1 Основные компоненты
- `PointsService` - управление очками пользователя
- `AchievementSystem` - система достижений
- `LevelSystem` - система уровней и прогресса

#### 2.4.2 Функциональность
- Начисление очков за активности
- Система уровней с прогрессивной шкалой опыта
- Достижения за различные действия
- История транзакций очков
- Система бонусов и множителей

## 3. Взаимодействие компонентов

### 3.1 Типичный поток данных
1. `EntryPoint` инициализирует `DIContainer` и регистрирует все сервисы
2. Пользователь взаимодействует с UI, выбирая эмоцию
3. `EmotionSelectionManager` вызывает методы `EmotionService`
4. `EmotionService` обновляет данные эмоций, генерирует события
5. `PointsService` начисляет очки за отметку эмоции
6. `EmotionSyncService` синхронизирует данные с Firebase
7. UI компоненты реагируют на изменения через события

### 3.2 Диаграмма основных взаимодействий
```
┌───────────┐        ┌───────────┐        ┌───────────┐
│ UI Layer  │───────▶│ Services  │───────▶│  Data     │
└───────────┘        └───────────┘        └───────────┘
      ▲                    │                    │
      │                    ▼                    ▼
┌───────────┐        ┌───────────┐        ┌───────────┐
│ Events    │◀───────│ Firebase  │◀───────│  Storage  │
└───────────┘        └───────────┘        └───────────┘
```

## 4. Ключевые алгоритмы и логика

### 4.1 Обработка эмоций
- Каждая эмоция представлена как `EmotionData` с типом, значением и интенсивностью
- Добавление эмоции увеличивает значение соответствующего типа
- При обработке учитывается максимальная ёмкость "банки" эмоции
- Смешивание эмоций происходит по правилам `EmotionMixingRules`

### 4.2 Синхронизация с Firebase
- Локальные изменения кэшируются в `EmotionHistoryCache`
- При наличии соединения, данные отправляются пакетами в Firebase
- Разрешение конфликтов по стратегии "последний выиграл" или ручное
- Поддержка offline режима работы с автоматической синхронизацией при восстановлении соединения

### 4.3 Система очков и прогресса
- Различные источники очков (`PointsSource`) с разными множителями
- Начисление опыта и повышение уровней (`LevelSystem`)
- Достижения активируются при выполнении специальных условий
- История транзакций для отслеживания всех изменений

## 5. Производительность и оптимизация

### 5.1 Оптимизации Firebase
- Использование `BatchManager` для пакетной отправки данных
- Кэширование запросов и оптимизация структуры данных
- Сжатие данных перед отправкой
- Интеллектуальное управление соединением

### 5.2 Результаты нагрузочного тестирования
- Умеренная нагрузка (7000 операций): 100% успешных операций, время отклика ~0.001с
- Экстремальная нагрузка (20000 операций): 100% успешных операций, макс. время отклика ~0.017с

## 6. Расширяемость

### 6.1 Добавление новых типов эмоций
1. Добавить новый тип в перечисление `EmotionTypes`
2. Создать конфигурацию в `EmotionConfig`
3. Добавить правила смешивания в `EmotionMixingRules`
4. Обновить UI для поддержки нового типа

### 6.2 Добавление новых игровых механик
1. Создать интерфейс сервиса (например, `IRewardService`)
2. Реализовать сервис (`RewardService`)
3. Зарегистрировать в `DIContainer`
4. Интегрировать с существующими системами через события

## 7. Текущее состояние и дальнейшее развитие

### 7.1 Завершенные задачи
- Базовая структура проекта (TASK-001) ✅
- Базовая логика эмоций (TASK-002) ✅
- Система данных и синхронизация Firebase (TASK-003) ✅
- Базовая система геймификации (TASK-004) ✅

### 7.2 Запланированные задачи
- Социальная система (TASK-005) ⏳
- Монетизация и реклама
- Расширенная визуализация эмоций
- Система уведомлений

## 8. Рекомендации для разработчиков

### 8.1 Стиль кодирования
- Следовать SOLID принципам
- Использовать интерфейсы для слабого связывания
- Документировать публичные методы и классы
- Соблюдать стандарты именования (_camelCase для приватных, PascalCase для публичных)

### 8.2 Процесс внесения изменений
1. Ознакомиться с существующей архитектурой и стилем кода
2. Использовать DI для внедрения зависимостей
3. Писать тесты для новой функциональности
4. Документировать изменения

### 8.3 Оптимизация
- Использовать object pooling для визуальных элементов
- Оптимизировать сетевые запросы к Firebase
- Следить за использованием памяти на мобильных устройствах 