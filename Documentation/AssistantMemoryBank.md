# Assistant Memory Bank для проекта MoodColor

## 1. Основная информация о проекте
### Описание
MoodColor - это мобильное приложение на Unity для Android, позволяющее пользователям отмечать свои эмоции, которые визуализируются в виде банок с жидкостью и цветными пузырьками. Цвет и структура жидкости зависят от эмоции.

### Ключевые особенности
- Визуализация эмоций через банки с жидкостью
- Firebase для регистрации и обновления базы данных в реальном времени
- Система пузырьков, отражающая эмоции в области и городе
- Статистика и история эмоций
- Игровые очки за отметку эмоций
- Система кастомизации банок
- Система уведомлений
- Социальные функции (добавление друзей)
- Рекламный сервис и система подписки

## 2. Архитектура проекта
### Структура папок
```
Assets/
├── App/
│   ├── Develop/
│   │   ├── EntryPoint/
│   │   ├── DI/
│   │   ├── CommonServices/
│   │   ├── AppServices/
│   │   │   └── Firebase/
│   │   ├── Utils/
│   │   └── Configs/
│   ├── Scenes/
│   ├── UI/
│   └── Resources/
├── Prefabs/
└── Settings/
```

### Ключевые компоненты
- DIContainer для внедрения зависимостей
- Firebase интеграция
- Система эмоций
- Визуальная система
- Система сохранения/загрузки

## 3. Технические детали
### Firebase конфигурация
- Database URL: https://moodcolor-3ac59-default-rtdb.firebaseio.com/
- App Name: MoodColorApp

### Важные классы и сервисы
- EntryPoint: Точка входа в приложение
- DIContainer: Контейнер зависимостей
- EmotionService: Сервис управления эмоциями
- PlayerDataProvider: Провайдер данных игрока
- ConfigsProviderService: Сервис конфигураций

## 4. Рабочий процесс
### Текущие задачи
- Настройка базовой структуры ✅
- Интеграция Firebase
- Разработка системы визуализации эмоций
- Создание UI
- Реализация геймификации

### Приоритеты разработки
1. Базовая функциональность
2. Визуализация эмоций
3. Социальные функции
4. Система наград
5. Монетизация

## 5. Стиль кодирования
### Принципы чистого кода
- Следовать SOLID принципам:
  - Single Responsibility (Единственная ответственность)
  - Open-Closed (Открытость-закрытость)
  - Liskov Substitution (Подстановка Лисков)
  - Interface Segregation (Разделение интерфейсов)
  - Dependency Inversion (Инверсия зависимостей)
- Писать самодокументируемый код с понятными именами
- Избегать дублирования кода (DRY принцип)
- Держать методы короткими и сфокусированными
- Использовать паттерны проектирования где это уместно

### Модульность и расширяемость
- Разделять логику на независимые модули
- Использовать абстракции для гибкости системы
- Применять слабое связывание через интерфейсы
- Создавать расширяемые компоненты через ScriptableObjects
- Использовать события для коммуникации между модулями
- Внедрять зависимости через DI контейнер
- Следовать компонентно-ориентированной архитектуре Unity

### Naming Conventions
- PascalCase для публичных членов
- _camelCase для приватных членов
- Использование #regions для организации кода
- [SerializeField] для приватных полей в инспекторе

### Структура классов
```csharp
public class ExampleClass : MonoBehaviour
{
    #region Constants
    private const int c_MaxItems = 100;
    #endregion

    #region Private fields
    [SerializeField] private int m_ItemCount;
    #endregion

    #region Unity Lifecycle
    private void Awake() { }
    #endregion

    #region Public Methods
    public void DoSomething() { }
    #endregion
}
```

## 6. Оптимизация
### Ключевые моменты
- Использование object pooling для пузырьков
- Оптимизация draw calls
- Эффективное использование Firebase
- Кэширование данных
- Управление памятью

## 7. Заметки и напоминания
- Всегда проверять зависимости перед созданием новых скриптов
- Использовать интерфейсы для слабого связывания
- Реализовывать события и делегаты где необходимо
- Документировать все публичные методы и классы
- Следить за производительностью на мобильных устройствах
- Проводить код-ревью на соответствие принципам чистого кода
- Планировать архитектуру с учётом будущих расширений
- Использовать юнит-тесты для проверки модульности
- Регулярно рефакторить код для поддержания чистоты

## 8. История обновлений
- 2024-04-27: Создана базовая структура проекта
- 2024-04-27: Настроена система внедрения зависимостей
- 2024-04-27: Интегрирован Firebase
- 2024-04-27: Добавлены принципы чистого кода и модульности 
- 2025-05-03: Обновлена документация проекта 